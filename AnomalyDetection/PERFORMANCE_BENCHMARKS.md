# Performance Benchmarks

## 概要

異常検知システムのパフォーマンスベンチマーク結果です。BenchmarkDotNet 0.15.5 を使用して測定されました。

## 実行環境

- **OS**: Windows 11 (10.0.22631.6060/23H2)
- **CPU**: Intel Core i5-8250U CPU 1.60GHz (Kaby Lake R), 4 Physical Cores, 8 Logical Cores
- **.NET Runtime**: .NET 9.0.9 (9.0.9, 9.0.925.41916), X64 RyuJIT x86-64-v3
- **GC**: Concurrent Workstation
- **Date**: 2025-11-02

## パフォーマンス目標

1. **メッセージスループット**: 1000 messages/second (1ms/message)
2. **閾値計算**: 100ms 未満
3. **メモリ効率**: Gen2 GC の最小化

## 1. メッセージスループットベンチマーク

### 1.1 シリアライゼーションスループット

メッセージの JSON 形式への変換パフォーマンス

| メッセージ数 | 平均時間 | スループット | メモリ割り当て | 評価        |
| ------------ | -------- | ------------ | -------------- | ----------- |
| 100 件       | 149.2 μs | 669 msg/s    | 41 KB          | ✅ 良好     |
| 500 件       | 629.6 μs | 794 msg/s    | 203 KB         | ✅ 良好     |
| 1000 件      | 1,196 μs | 836 msg/s    | 406 KB         | ⚠️ 目標未達 |

**分析**:

- 1000 メッセージでは目標の 1000 msg/sec に若干届かず（836 msg/sec）
- Gen2 GC が発生（33.2KB）しているため、大量メッセージ処理時に GC 圧力がかかる可能性あり

### 1.2 並列シリアライゼーション

Parallel.ForEach を使用した並列処理

| メッセージ数 | 平均時間 | スループット | 改善率 | メモリ割り当て | 評価            |
| ------------ | -------- | ------------ | ------ | -------------- | --------------- |
| 100 件       | 132.0 μs | 758 msg/s    | +13%   | 44 KB          | ✅ 良好         |
| 500 件       | 397.1 μs | 1,259 msg/s  | +59%   | 210 KB         | ✅ **目標達成** |
| 1000 件      | 745.3 μs | 1,342 msg/s  | +60%   | 415 KB         | ✅ **目標達成** |

**分析**:

- 並列化により 500 件・1000 件で目標の 1000 msg/sec を達成
- 100 件では並列化オーバーヘッドにより逆にスループット低下
- 推奨: 200 件以上の場合に並列処理を使用

### 1.3 シーケンシャルメッセージ処理

順次処理（Task.Yield による最小遅延シミュレーション）

| メッセージ数 | 平均時間 | 1 メッセージあたり | 評価    |
| ------------ | -------- | ------------------ | ------- |
| 100 件       | 156.4 μs | 1.56 μs/msg        | ✅ 優秀 |
| 500 件       | 745.1 μs | 1.49 μs/msg        | ✅ 優秀 |
| 1000 件      | 1,367 μs | 1.37 μs/msg        | ✅ 優秀 |

**分析**:

- 1 メッセージあたり約 1.5μs（目標: 1ms）で処理可能
- 実際の SignalR 送信オーバーヘッドは含まれていない
- メモリ効率が高く、Gen2 GC が発生しない

### 1.4 並列メッセージ処理

Task.WhenAll を使用した並列非同期処理

| メッセージ数 | 平均時間 | スループット | 評価        |
| ------------ | -------- | ------------ | ----------- |
| 100 件       | 59.0 μs  | 1,695 msg/s  | ✅ **優秀** |
| 500 件       | 297.0 μs | 1,684 msg/s  | ✅ **優秀** |
| 1000 件      | 664.8 μs | 1,504 msg/s  | ✅ **優秀** |

**分析**:

- **全ケースで目標の 1000 msg/sec を大幅に超過**
- 最も効率的なメッセージ処理パターン
- 推奨: リアルタイム通知には並列非同期処理を使用

### 1.5 バッチメッセージ処理

10 メッセージ単位でのバッチ処理

| メッセージ数 | 平均時間 | スループット | 評価        |
| ------------ | -------- | ------------ | ----------- |
| 100 件       | 194.6 μs | 514 msg/s    | ⚠️ 目標未達 |
| 500 件       | 942.7 μs | 530 msg/s    | ⚠️ 目標未達 |
| 1000 件      | 1,946 μs | 514 msg/s    | ⚠️ 目標未達 |

**分析**:

- バッチサイズ 10 では目標未達
- バッチ処理による遅延が発生
- リアルタイム性が重要な場合は非推奨

## 2. メモリ割り当て分析

### GC 発生状況

| 処理パターン                 | 100 件      | 500 件      | 1000 件   |
| ---------------------------- | ----------- | ----------- | --------- |
| **シリアライゼーション**     | Gen0/1 のみ | Gen0/1 のみ | Gen0/1/2  |
| **並列シリアライゼーション** | Gen0/1 のみ | Gen0/1/2    | Gen0/1/2  |
| **シーケンシャル**           | Gen0 のみ   | Gen0 のみ   | Gen0 のみ |
| **並列非同期**               | Gen0 のみ   | Gen0/1      | Gen0/1    |
| **バッチ**                   | Gen0 のみ   | Gen0 のみ   | Gen0 のみ |

**推奨事項**:

- **大量メッセージ（1000 件以上）**: シーケンシャル処理またはバッチ処理を検討（Gen2 GC 回避）
- **リアルタイム性重視**: 並列非同期処理（スループット最優先）
- **中規模（200-999 件）**: 並列シリアライゼーション（バランス型）

## 3. 総合評価

### ✅ 達成項目

1. **並列非同期処理で目標スループット達成**: 1,500+ msg/sec（目標: 1,000 msg/sec）
2. **低遅延処理**: 1 メッセージあたり 1.5μs（シーケンシャル）
3. **スケーラビリティ**: 100 件 →1000 件で線形スケール

### ⚠️ 改善推奨項目

1. **Gen2 GC 発生**: 1000 件以上の並列処理で Gen2 GC 発生
   - 対策: オブジェクトプーリング、ArrayPool の使用
2. **バッチ処理の最適化**: バッチサイズ 10 では効率が悪い
   - 対策: 動的バッチサイズ調整（50-100 件/batch）

## 4. 推奨アーキテクチャ

```csharp
// リアルタイム通知（優先度: 高）
// - 並列非同期処理を使用
// - 目標スループット: 1,500 msg/sec
await Task.WhenAll(messages.Select(msg =>
    hubContext.Clients.All.SendAsync("AnomalyDetected", msg)
));

// 大量データ処理（優先度: 中）
// - 並列シリアライゼーションを使用
// - 200件以上の場合に有効
Parallel.ForEach(messages, msg =>
    SerializeAndProcess(msg)
);

// バックグラウンド処理（優先度: 低）
// - シーケンシャル処理を使用
// - GC圧力最小化
foreach (var msg in messages)
{
    await ProcessMessageAsync(msg);
}
```

## 5. ベンチマーク実行コマンド

```bash
# 全ベンチマーク実行
cd test/AnomalyDetection.PerformanceBenchmarks
dotnet run -c Release

# 特定のベンチマークのみ実行
dotnet run -c Release -- --filter *MessageThroughputBenchmark*
dotnet run -c Release -- --filter *DetectionPerformanceBenchmark*
```

## 6. 次のステップ

1. **異常検知アルゴリズムのベンチマーク実行**

   - 閾値計算パフォーマンス（目標: <100ms）
   - 外れ値検出（IQR, Z-Score）

2. **実環境シミュレーション**

   - SignalR 実装を含む統合テスト
   - Redis 接続を含むエンドツーエンドテスト

3. **最適化実装**
   - オブジェクトプーリングの導入
   - 非同期ストリーム処理の検討

---

**最終更新**: 2025-11-02  
**BenchmarkDotNet バージョン**: 0.15.5  
**プロジェクト**: AnomalyDetection.PerformanceBenchmarks
